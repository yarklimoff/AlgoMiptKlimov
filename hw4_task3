// https://contest.yandex.ru/contest/18281/run-report/33208042/
#include <iostream>
#include <vector>
#define INF 1000000

void build(std::vector<long> &colors, long curr, long l, long r, std::vector<std::pair<long, long>>& tree) {
  if (l == r) {
    tree[curr].first = colors[l];
  } else {
    long m = (l + r) / 2;
    build(colors, curr * 2, l, m, tree);
    build(colors, curr * 2 + 1, m + 1, r, tree);
    tree[curr].first = std::min(tree[curr * 2].first, tree[curr * 2 + 1].first);
  }
}

void push(long curr, std::vector<std::pair<long, long>>& tree) {
  if (curr < tree.size() && tree[curr].second != -1) {
    if (curr * 2 < tree.size()) {
      tree[curr * 2].second = tree[curr].second;
    }
    if (curr * 2 + 1 < tree.size()) {
      tree[curr * 2 + 1].second = tree[curr].second;
    }

    tree[curr].first = tree[curr].second;
    tree[curr].second = -1;
  }
}

void update(long curr, long L, long R, long l, long r, long color, std::vector<std::pair<long, long>>& tree) {
  if (l > r) {
      return;
  }
  if (l == L && r == R) {
    tree[curr].second = color;
  } else {
    push(curr, tree);
    long m = (L + R) / 2;
    update(curr * 2, L, m, l, std::min(r, m), color, tree);
    update(curr * 2 + 1, m + 1, R, std::max(l, m + 1), r, color, tree);
    push(curr * 2, tree);
    push(curr * 2 + 1, tree);
    tree[curr].first = std::min(tree[curr * 2].first, tree[curr * 2 + 1].first);
  }
}

long get(long curr, long L, long R, long l, long r, std::vector<std::pair<long, long>>& tree) {
  if (l > r) {
      return INF;
  }
  push(curr, tree);
  if (l == L && r == R) {
    return tree[curr].first;
  } else {
    long m = (L + R) / 2;
    return std::min(get(curr * 2, L, m, l, std::min(m, r), tree),
                    get(curr * 2 + 1, m + 1, R, std::max(l, m + 1), r, tree));
  }
}

long query(long l, long r, long number, long L, long R, long size, std::vector<std::pair<long, long>>& tree) {
    update(1, 0, size - 1, l, r, number, tree);
    return get(1, 0, size - 1, L, R, tree);
}

int main() {
    long N = 0;
    std::cin >> N;
    std::vector<long> colors(N, 0);
    for (long i = 0; i < N; ++i) {
        long R, G, B;
        std::cin >> R >> G >> B;
        colors[i] = R + G + B;
    }
    std::vector<std::pair<long, long> > tree(4 * N, std::make_pair(INF, -1));
    build(colors, 1, 0, N - 1, tree);
    long K;
    std::cin >> K;
    for (long i = 0; i < K; ++i) {
        long C, D, R, G, B, E, F;
        std::cin >> C >> D >> R >> G >> B >> E >> F;
        std::cout << query(C, D, R + G + B, E, F, N, tree) << " ";
    }
  return 0;
}
