// https://contest.yandex.ru/contest/17986/run-report/32850320/
#include "iostream"
#include "vector"

enum Bool {False = 0, True};

bool dfs(int& v, std::vector<Bool>& used, std::vector<int>& matching, std::vector<std::vector<int>>& matrix) {
    if (used[v] == True) {
        return false;
    }
    used[v] = True;
    for (int to : matrix[v]) {
        if (matching[to] == -1 || dfs(matching[to], used, matching, matrix)) {
            matching[to] = v;
            return true;
        }
    }
    return false;
}

void partition(std::vector<int>& part, std::vector<std::vector<int>>& matrix) {
    int n = part.size();
    std::vector<int> q(n);
    for (int i = 0; i < n; ++i)
        if (part[i] == -1) {
            int h = 0, t = 0;
            q[t++] = i;
            part[i] = 0;
            while (h < t) {
                int v = q[h++];
                for (int i = 0; i < matrix[v].size(); ++i) {
                    int to = matrix[v][i];
                    if (part[to] == -1)
                        part[to] = !part[v],  q[t++] = to;
                }
            }
        }
}

int algoKuhn(std::vector<std::vector<int>>& graph, int number_of_voids) {
    int n = graph.size();
    int m = graph[0].size();
    std::vector<std::vector<int>> matrix(number_of_voids, std::vector<int> ());
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (graph[i][j] >= 0) {
                if (i >= 1 && graph[i-1][j] >= 0) {
                    matrix[graph[i][j]].push_back(graph[i - 1][j]);
                }
                if (i + 1 < n && graph[i + 1][j] >= 0) {
                    matrix[graph[i][j]].push_back(graph[i + 1][j]);
                }
                if (j >= 1 && graph[i][j - 1] >= 0) {
                    matrix[graph[i][j]].push_back(graph[i][j - 1]);
                }
                if (j + 1 < m && graph[i][j + 1] >= 0) {
                    matrix[graph[i][j]].push_back(graph[i][j + 1]);
                }
            }
        }
    }
    n = number_of_voids;
    std::vector<int> part(n, -1);
    partition(part, matrix);
    for (int i = 0; i < n; ++i) {
        if (part[i] == 1) {
            matrix[i].clear();
        }
    }
    int ans = 0;
    std::vector<int> mt(n, -1);
    std::vector<Bool> used(n);
    for (int i = 0; i < n; i++) {
        std::fill(used.begin(), used.end(), False);
        if (dfs(i, used, mt, matrix))
            ++ans;
    }
    return ans;
}

int main() {
    int n, m, a, b, number_of_voids = 0;
    std::cin >> n >> m >> a >> b;
    char symbol;
    std::vector<std::vector<int>> graph(n, std::vector<int> (m, -1));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            std::cin >> symbol;
            if (symbol == '*') {
                graph[i][j] = number_of_voids;
                ++number_of_voids;
            }
        }
    }
    if (2 * b <= a)
        std::cout << number_of_voids * b;
    else {
        int long_ways = algoKuhn(graph, number_of_voids);
        std::cout <<  long_ways * a + b * (number_of_voids - 2 * long_ways);
    }
    return 0;
}

