// https://contest.yandex.ru/contest/18281/run-report/33217009/
#include <iostream>
#include <vector>

bool isChild(long long from, long long to, std::vector<long long>& in, std::vector<long long>& out) {
    return (in[from] <= in[to]) && (out[from] >= out[to]);
}

long long query(std::pair<long long, long long> pairQuery, long long log, std::vector<long long>& in,
                std::vector<long long>& out, std::vector<std::vector<long long>>& parents) {
    if (isChild(pairQuery.first, pairQuery.second, in, out)) return pairQuery.first;
    if (isChild(pairQuery.second, pairQuery.first, in, out)) return pairQuery.second;
    for (long long node = log; node >= 0; --node) {
        if (!isChild(parents[pairQuery.first][node], pairQuery.second, in, out)) {
            pairQuery.first = parents[pairQuery.first][node];
        }
    }
    return parents[pairQuery.first][0];
}

std::pair<long long, long long> next(long long& result, long long& a1, long long& a2, long long& x, long long& y, long long& z, long long& n) {
    std::pair<long, long> newQuery = std::make_pair((a1 + result) % n, a2);
    a1 = (x * a1 + y * a2 + z) % n;
    a2 = (x * a2 + y * a1 + z) % n;
    return newQuery;
}

void dfs(long long curr, long long parent, long long& time, long long log, std::vector<long long>& in,
        std::vector<long long>& out, std::vector<std::vector<long long>>& graph,
        std::vector<std::vector<long long>>& parents) {
    in[curr] = ++time;
    parents[curr][0] = parent;
    for (long long parentIndex = 1; parentIndex <= log; ++parentIndex) {
        parents[curr][parentIndex] = parents[parents[curr][parentIndex - 1]][parentIndex - 1];
    }
    for (auto& child : graph[curr]) {
        if (child != parent) {
            dfs(child, curr, time, log, in, out, graph, parents);
        }
    }
    out[curr] = ++time;
}

int main() {
    long long n, m, log = 1, a1, a2, x, y, z, answer = 0, sum = 0;
    std::cin >> n >> m;
    while ((1 << log) <= n) {
        ++log;
    }
    std::vector<std::vector<long long>> graph(n);
    std::vector<long long> in(n, 0);
    std::vector<long long> out(n, 0);
    std::vector<std::vector<long long> > parents(n, std::vector<long long>(log + 1));
    long long time = 0, size = n;
    for (long long i = 1; i < size; ++i) {
        long long b;
        std::cin >> b;
        graph[b].push_back(i);
    }
    dfs(0, 0, time, log, in, out, graph, parents);
    std::cin >> a1 >> a2 >> x >> y >> z;
    for (long long i = 0; i < m; ++i) {
        answer = query(next(answer, a1, a2, x, y, z, n), log, in, out, parents);
        sum += answer;
    }
    std::cout << sum << std::endl;
    return 0;
}
